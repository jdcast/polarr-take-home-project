# References:
# 1) https://www.embedded.com/design/mcus-processors-and-socs/4007154/Use-OpenMP-for-programming-parallel-threads-in-multicore-applications-Part-1

# I assume that OpenMP compiler and runtime library is available.

int *get_greyscale(int* input)
{
	int num_pixels = image_width*image_height;
	output_greyscale[num_pixels] = {0};

	#pragma omp parallel for
	for (int i=0; i < numPixels; i++)
	{
		int pixel_idx = i*3 // each pixel is 3 bytes
	    output_greyscale[i] = (unsigned char)
	                            (input[pixel_idx] * 0.2999 + // red
	                            input[pixel_idx+1] * 0.5870 + // green
	                            input[pixel_idx+2] * 0.1140); // blue
	}
	return output_greyscale;
}

# Another approach might be to:
# 1) get number of cpus available (cores)
# 2) set up a thread pool/work queue of threads of size equal to number of cores
# 3) programmatically set the thread affinity of each thread to a specific core
# 4) use a master thread to manage the work queue and doll out parcels of the image to compute to each worker thread

# Reference: https://eli.thegreenplace.net/2016/c11-threads-affinity-and-hyperthreading/